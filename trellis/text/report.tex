\documentclass[a4paper,12pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}

\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}
\newtheorem{statement}{Утверждение}
\newtheorem{definition}{Опр.}

\newenvironment{proof}[1][Доказательство]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\newcommand{\qed}{\nobreak \ifvmode \relax \else
      \ifdim\lastskip<1.5em \hskip-\lastskip
      \hskip1.5em plus0em minus0.5em \fi \nobreak
      \vrule height0.75em width0.5em depth0.25em\fi}

\begin{document}
\lstset{language=Java}

\section{Введение}

Цель данной работы – разработка программы, эмулирующей работу скрытого канала с мультипликативной помехой 
различного уровня интенсивности, использующей TRELLIS коды для помехоустойчивого кодирования передаваемой
информации. Варианты TRELLIS кодов выбираются из рекомендаций международного союза электросвязи 
ITU-T V.32 \cite{stV32}, V.32bis \cite{stV32bis}. 

\section{Постановка задачи}
Задача разбивается на несколько модулей:

\begin{enumerate}
    \item Реализация алгоритма TRELLIS кодирования по рекоммендациям ITU-T V.32, V.32bis.
    \item Имитация канала связи с мультипликативной ошибкой.
    \item Реализация алгоритма декодирования Витерби.
\end{enumerate}

Заметим, что, поскольку разрабатываемое ПО носит исследовательский, а не прикладной характер, то разработка
велась исходя из необходимости обеспечить максимальное удобство при отладке, иногда даже в ущерб эффективности
в плане производительности.

\section{Описание алгоритмов}

\subsection{Алгоритм TRELLIS кодирования}
Алгоритм TRELLIS кодидования похож на алгоритмы сверточного кодирования тем, что кодирующее устройство может
находится в одном из нескольких состояний, в зависимости от которого происходит кодирование. Однако есть и
существенные отличия, главное состоит в том, что кодер выдает не цифровой, а аналоговый сигнал, таким образом
фазы кодирования и модуляции сигнала не разделяются.
Опишем данное утверждение более формально.

Кодом назовем функцию: $S \times \Sigma \rightarrow R^2 \times S$, где:
\begin{itemize}
	\item $S$ --- некоторое конечное множество состояний ($S_0 \ldots S_n$).
	\item $\Sigma$ --- алфавит, с которым работает кодер.
\end{itemize}
Данная функция по текущему состоянию $s \in S$ и текущему входоному символу $x \in \Sigma$ возвращает вектор
$\vec{a} \in R^2$ --- аналоговый сигнал (амплитуда и фаза), а также новое состояние.

Перейдем теперь к конкретным стандартам.

\subsubsection{V32}
Входной символ представляет собой четыре бита ($Q_1 \ldots Q_4$), т.е. $\Sigma = \{0, 1\}^4$. Кодер имеет $8$
состояний, т.е. три бита --- $S_0$, $S_1$, $S_2$. Схема вычисления функциий изображена на рисунке \ref{y0V32}.

\begin{figure}
	\center{\includegraphics[scale=1]{pic\schemeV32}}
	\caption{Схема кодирующего устройства стандарта V32}
	\label{schemeV32}
\end{figure}

Под element signal mapper подразумевается преобразователь сигнала в аналоговый вид. Преобразование осуществляется
при помощи схемы, изображееной на рисунке \ref{mapperV32}.

\begin{figure}
	\center{\includegraphics[scale=1]{pic\mapperV32}}
	\caption{Схема кодирующего устройства стандарта V32}
	\label{schemeV32}
\end{figure}

\subsubsection{V32bis}

\subsection{Имитация канала с ошибкой}

\subsection{Алгоритм Витерби для TRELLIS декодирования}

\section{Описание работы програамы}

\section{Зaключение}

\bibliography{report}

\end{document}
